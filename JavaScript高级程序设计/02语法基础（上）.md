### 1. 语法

-   区分大小写

-   标识符

    即变量、函数、属性或函数参数的名称，可由一或多个下列字符组成：

    -   首字符必须是字母、`_` 或 `$`
    -   其他字符可以是字母、`_`、`$` 或数字

    标识符中的字母可以是扩展 ASCII 中的字母，也可以是 Unicode 的字母字符，但只推荐使用 ASCII 字母。

    按照惯例，标识符使用小驼峰形式，即第一个单词的首字母小写，后面每个单词的首字母大写。

    >   关键字、保留字、`true`、`false` 和 `null` 不能作为标识符。

-   注释

    分为单行注释和块注释：

    ```javascript
    // 单行注释
    
    /*
    	块注释
    */
    ```

-   严格模式

    ECMAScript 5 增加了**严格模式**。严格模式对原来版本中的一些不规范的写法进行处理，对于不安全的活动将抛出错误。要对整个脚本启用严格模式，在脚本开头加上这一行：

    ```javascript
    "use strict"; // 严格模式的预处理指令，任何支持的 JavaScript 引擎都会识别它
    ```

    也可以单独指定一个函数在严格模式下执行，把这个指令放到函数体开头即可：

    ```javascript
    function doSomething() {
        "use strict";
        // 函数体
    }
    ```

-   语句

    ECMAScript 中的语句以分号结尾。省略分号意味着由解析器确定语句在哪里结尾，如：

    ```javascript
    let sum = a + b   // 没有分号有效，但不推荐 -- 但是这种写法已经在一定程度上成为了主流
    let diff = a - b; // 推荐写法
    ```

    -   加分号可以避免不必要的语法错误
    -   加分号便于开发者通过删除空行来压缩代码（如果没有结尾的分号，只删除空行，则会导致语法错误）
    -   加分号有助于在某些情况下提升性能，因为解析器会尝试在合适的位置补上分号以纠正语法错误

    多条语句可以合并到一个 C 语言风格的代码块中。代码块由 `{` 标识开始，`}` 标识结束：

    ```javascript
    if (test) {
        test = false;
        console.log(test);
    }
    ```

    `if` 之类的控制语句只在执行多条语句时要求必须有代码块。不过，最佳实践是始终在控制语句中使用代码块，即使要执行的只有一条语句，如：

    ```javascript
    // 有效，但不推荐 -- 当语句仅为一个 return 关键字时，常用这种写法
    if (test)
        console.log(test);
    
    // 推荐
    if (test) {
        console.log(test);
    }
    ```

### 2. 关键字和保留字

ECMA-262 第 6 版规定的关键字：

```javascript
break		case		catch		class		const		continue
debugger	default		delete		do			else		export
extends		finally		for			function	if			import
in			instanceof	new			return		super		switch
this		throw		try			typeof		var			void
while		with		yield
```

ECMA-262 第 6 版规定的保留字：

```javascript
// 始终保留
enum
// 严格模式下保留
implements		interface		let		package		protected
private			public			static
// 模块代码中保留
await
```

这些词汇不能用作标识符，但现在还可以用作对象的属性名。一般来说，最好还是不要使用关键字和保留字作为标识符和属性名，以确保兼容过去和未来的 ECMAScript 版本。

### 3. 变量

ECMAScript 变量是松散类型的，即可以用于保存任何类型的数据。每个变量只不过是一个用于保存任意值的命名占位符。有 3 个关键字可以声明变量：`var`、`const` 和 `let`。其中，`var` 在 ECMAScript 的所有版本中都可以使用，而 `const` 和 `let` 只能在 ECMAScript 6 及更晚的版本中使用。

#### 3.1 `var`关键字

定义变量可以使用 `var` 关键字，后跟变量名：

```javascript
var message;
```

不初始化的情况下，变量会保存一个特殊值 `undefined`。

可以同时定义一个变量并赋值，即变量初始化：

```javascript
var message = "hi";
```

变量不仅可以修改值，还可以修改类型：

```javascript
var message = "hi";
message = 100; // 合法，但不推荐
```

##### 3.1.1 `var`声明作用域

使用 `var` 定义的变量会成为包含它的函数的局部变量。比如，使用 `var` 在一个函数内部定义一个变量，就意味着该变量将在函数退出时被销毁：

```javascript
function test() {
    var message = "hi"; // 局部变量
}
test();
console.log(message); // 出错
```

在函数内定义变量时省略 `var`，可以创建一个全局变量：

```javascript
function test() {
    message = "hi"; // 全局变量
}
test();
console.log(message); // "hi"
```

>   这种写法不推荐，可读性差，还难以维护。在严格模式下，给未声明的变量赋值，则会导致抛出 `ReferenceError`。

如果需要定义多个变量，可以在一条语句中用逗号分隔每个变量（及可选的初始化）：

```javascript
var message = "hi",
    found = false,
    age = 18;
```

在严格模式下，不能定义名为 `eval` 和 `arguments` 的变量，否则会导致语法错误。

##### 3.1.2 `var` 声明提升

使用 `var` 时，下面的代码不会报错，因为变量的声明会自动提升到函数作用域顶部：

```javascript
function foo() {
    console.log(age);
    var age = 26; // 声明会提升，但赋值不会
}
foo(); // undefined
```

等价于：

```javascript
function foo() {
    var age;
    console.log(age);
    age = 26;
}
foo(); // undefined
```

反复多次使用 `var` 声明同一个变量不会出现问题：

```javascript
function foo() {
    var age = 16;
    var age = 26; // 等价于 age = 26
    var age = 36;
    console.log(age);
}
foo(); // 36
```

#### 3.2 `let` 声明

`let` 跟 `var` 的作用差不多，但有着非常重要的区别。最明显的区别是，`let` 声明的范围是块作用域，而 `var` 声明的范围是函数作用域。

```javascript
if (true) {
    var name = 'Matt'
    console.log(name); // Matt
}
console.log(name); // Matt

if (true) {
    let age = 26;
    console.log(age); // 26
}
console.log(age); // ReferenceError: age 没有定义
```

块作用域是函数作用域的子集，因此适用于 `var` 的作用域限制同样也适用于 `let`。

`let` 不允许同一个块作用域中出现冗余声明，这样会导致报错：

```javascript
var name;
var name;
let age;
let age; // SyntaxError: 标识符 age 已经声明过了
```

JavaScript 引擎会记录用于变量声明的标识符及其所在的块作用域，因此嵌套使用相同的标识符不会报错，因为在同一个块中没有重复声明：

```javascript
var name = 'Nicholas';
console.log(name); // 'Nicholas'

if (true) {
    var name = 'Matt';
    console.log(name); // 'Matt'
}

let age = 30;
console.log(age); // 30

if (true) {
    let age = 26;
    console.log(age); // 26
}
```

对声明冗余报错不会因混用 `let` 和 `var` 而受影响。这两个关键字声明的并不是不同类型的变量，它们只是指出变量在相关作用域如何存在。

```javascript
var name;
let name; // SyntaxError
let age;
var age; // SyntaxError
```

##### 3.2.1 暂时性死区

`let` 与 `var` 的另一个重要的区别，就是 `let` 声明的变量不会在作用域中被提升。

```javascript
// name 会被提升
console.log(name); // undefined
var name = 'Matt';
// age 不会被提升
console.log(age); // ReferenceError: age 没有定义
let age = 26;
```

在 `let` 声明之前的执行瞬间被称为**暂时性死区**（temporal dead zone），在此阶段引用任何后面才声明的变量都会抛出 `ReferenceError`。

##### 3.2.2 全局声明

与 `var` 关键字不同，使用 `let` 在全局作用域中声明的变量不会成为 `window` 对象的属性（`var` 声明的变量则会）。

```javascript
var name = 'Matt';
console.log(window.name); // 'Matt'
let age = 26;
console.log(window.age); // undefined
```

为了避免 `SyntaxError`，必须确保页面不会重复声明同一个变量。

##### 3.2.3 条件声明

在使用 `var` 声明变量时，由于声明会被提升，JavaScript 引擎会自动将多余的声明在作用域顶部合并为一个声明。因为 `let` 的作用域是块，所以不可能检查前面是否已经使用 `let` 声明过同名变量，同时也就不可能在没有声明的情况下声明它。

```html
<script>
	var name = 'Nicholas';
    let age = 26;
</script>
<script>
	// 假设脚本不确定页面中是否已经声明了同名变量
    // 那它可以假设没有声明过
    var name = 'Matt';
    // 这里没问题，因为可以被作为一个提升声明来处理
    // 不需要检查之前是否声明过同名变量
    let age = 36;
    // 如果 age 之前声明过，这里会报错
</script>
```

使用 `try/catch` 语句或 `typeof` 操作符也不能解决，因为条件块中 `let` 声明的作用域仅限于该块。

```html
<script>
	let name = 'Nicholas';
    let age = 36;
</script>
<script>
	// 假设脚本不确定页面中是否已经声明了同名变量
    // 那它可以假设没有声明过
    if (typeof name === 'undefined') {
        let name;
    }
    // name 被限制在 if{} 块的作用域内
    // 因此这个赋值形同全局赋值
    name = 'Matt';
    try {
        console.log(age) // 如果 age 没有声明过，则会报错
    }
    catch(error) {
        let age;
    }
    // age 被限制在 catch{} 块的作用域内
    // 因此这个赋值形同全局赋值
    age = 26;
</script>
```

因此，对于 `let` 这个新的 ES6 声明关键字，不能依赖条件声明模式。

##### 3.2.4 `for` 循环中的 `let` 声明

在 `let` 出现之前，`for` 循环定义的迭代变量会渗透到循环体外部：

```javascript
for (var i = 0; i < 5; ++i) {
    // 循环逻辑
}
console.log(i); // 5
```

使用 `let` 之后，这个问题就消失了，因为迭代变量的作用域仅限于 `for` 循环块内部：

```javascript
for (let i = 0; i < 5; ++i) {
    // 循环逻辑
}
console.log(i); // // ReferenceError: i 没有定义
```

在使用 `var` 的时候，最常见的问题就是对迭代变量的奇特声明和修改：

```javascript
for (var i = 0; i < 5; ++i) {
    setTimeout(() => console.log(i), 0);
}
// 输出 5、5、5、5、5
```

之所以会这样，是因为在退出循环时，迭代变量保存的是导致循环退出的值：5。在之后执行超时逻辑时，所有的 `i` 都是同一个变量，因而输出的都是同一个最终值。

而在使用 `let` 声明迭代变量时，JavaScript 引擎在后台会为每个迭代循环声明一个新的迭代变量。每个 `setTimeout` 引用的都是不同的变量实例，所以 `console.log` 输出的是循环执行过程中每个迭代变量的值。

```javascript
for (let i = 0; i < 5; ++i) { // 总共有 6 个 i, () 内一个，每次循环声明一个
    setTimeout(() => console.log(i), 0);
}
// 输出 0、1、2、3、4
```

这种每次迭代声明一个独立变量实例的行为适用于所有风格的 `for` 循环，包括 `for-in` 和 `for-of` 循环。

#### 3.3 `const` 声明

`const` 的行为与 `let` 基本相同，唯一一个重要的区别是用它声明变量时必须同时初始化变量，且尝试修改 `const` 声明的变量会导致运行时错误。

```javascript
const age = 26;
age = 36; // TypeError: 给常量赋值
// const 不允许重复声明
const name = 'Matt';
const name = 'Nicholas'; // SyntaxError
// const 声明的作用域也是块
const name = 'Matt';
if (true) {
    const name = 'Nicholas';
}
console.log(name); // Matt
```

`const` 声明的限制只适用于它指向的变量的引用，如果 `const` 变量引用的是一个对象，那么修改这个对象内部的属性并不违反 `const` 的限制。

```javascript
const person = {};
person.name = 'Matt'; // 合法
```

JavaScript 引擎会为 `for` 循环中的 `let` 声明分别创建独立的变量实例，虽然 `const` 变量跟 `let` 变量很相似，但是不能用 `const` 来声明迭代变量（因为迭代变量会自增）：

```javascript
for (const i = 0; i < 10; ++i) {} // TypeError: 给常量赋值
```

如果你只想用 `const` 声明一个不会被修改的 `for` 循环变量，那也是可以的。也就是说，每次迭代只是创建一个新变量。这对 `for-of` 和 `for-in` 循环特别有意义：

```javascript
let i = 0;
for (const j = 7; i < 5; ++i) {
    console.log(j);
}
// 7, 7, 7, 7, 7

for (const key in { a: 1, b: 2 }) {
    console.log(key);
}
// a, b

for (const value of [1, 2, 3, 4, 5]) {
    console.log(value);
}
// 1, 2, 3, 4, 5
```

#### 3.4 声明风格和最佳实践

1.   不使用 `var`

     限制自己只使用 `let` 和 `const` 有助于提升代码质量，因为变量有了明确的作用域、声明位置，以及不变的值。

2.   `const` 优先，`let` 次之

     使用 `const` 声明可以让浏览器运行时强制保持变量不变，也可以让静态代码分析工具提前发现不合法的赋值操作。因此，很多开发者认为应该优先使用 `const`，只在提前知道未来会有修改时再使用 `let`。

### 4. 数据类型

ECMAScript 有 6 种简单数据类型（也称为**原始类型**）: `Undefined`、`Null`、`Boolean`、`Number`、`String` 和 `Symbol`（ECMAScript 6 新增）。还有一种复杂数据类型叫 `Object`（对象）。只有 7 种数据类型似乎不足以表示全部数据。但 ECMAScript 的数据类型很灵活，一种数据类型可以当作多种数据类型来使用。

>   ECMAScript 2020 又新增了基本数据类型 BigInt，表示任意大的整数。

#### 4.1 `typeof` 操作符

`typeof` 操作符用来确定任意变量的数据类型。对一个值使用 `typeof` 操作符会返回下列**字符串**之一：

-   `undefined` 表示值未定义
-   `boolean` 表示值为布尔值
-   `string` 表示值为字符串
-   `number` 表示值为数值
-   `object` 表示值为对象（而不是函数）或 `null`（被认为是一个对空对象的引用）
-   `function` 表示值为函数
-   `symbol` 表示值为符号

```javascript
let message = "some string";
console.log(typeof message); // string
console.log(typeof(message)); // string
console.log(typeof 100); // number
```

`typeof` 是一个操作符而不是函数，所以不需要参数（但可以使用参数）。

#### 4.2 Undefined 类型

Undefined 类型只有一个值，就是特殊值 `undefined`。当使用 `var` 或 `let` 声明了变量但没有初始化时，就相当于给变量赋予了 `undefined` 值：

```javascript
let message;
console.log(message == undefined); // true
```

任何未经初始化的变量都会取得 `undefined` 值。

不要显示地给某个变量赋 `undefined` 值，增加这个特殊值的目的就是为了正式明确空对象指针 `null` 和未初始化变量的区别。

对未声明的变量，只能执行一个有用的操作，就是对它调用 `typeof`（对未声明的变量调用 `delete` 也不会报错，但这个操作没有意义，且在严格模式下会抛出错误）。

在对未初始化的变量调用 `typeof` 时，返回的结果是 `undefined`，对未声明的变量调用 `typeof` 也返回 `undefined`。

```javascript
let message;
console.log(typeof message); // undefined
console.log(typeof age); // undefined
```

>   即使未初始化的变量会被自动赋予 `undefined` 值，但仍建议在声明变量的同时进行初始化。这样，当 `typeof` 返回 `undefined` 时，就会知道那是因为给定的变量尚未声明，而不是声明了但未初始化。

undefined是一个假值（fasly）。

```javascript
let message;

if (message) {
    // 不会执行
}

if (age) {
    // 报错
}
```

#### 4.3 Null 类型

Null 类型同样只有一个值，即 `null`。逻辑上讲，`null` 值表示一个空对象指针，这也是给 `typeof` 传一个 `null` 会返回 `object` 的原因：

```javascript
let car = null;
console.log(typeof car); // object
```

>   有一种说法是：JavaScript 引擎会将最高三个二进制位为 `000` 的值解释为对象类型，`null` 在 ASCII 码中对应为 0，即二进制全为 0，故被解释为对象类型。

在定义将来要保存对象值的变量时，建议使用 `null` 来初始化。这样，只要检查这个变量的值是不是 `null` 就可以知道这个变量是否在后来被重新赋予了一个对象的引用，如：

```javascript
if (car != null) {
    // car 是一个对象的引用
}
```

`undefined` 值是由 `null` 值派生而来的，因此被定义为表面上相等：

```javascript
console.log(null == undefined); // true
```

`null` 是一个假值。

```javascript
let car = null;
if (car) {
    // 不会执行
}
```

#### 4.4 Boolean类型

Boolean 类型包含两个值：`true` 和 `false`。

要将一个其他类型的值转换为布尔值，可以调用 `Boolean()` 函数：

```javascript
let message = "Hello world!";
let messageAsBoolean = Boolean(message);
```

| 数据类型  |   转换为 `true` 的值   | 转换为 `false` 的值 |
| :-------: | :--------------------: | :-----------------: |
|  Boolean  |         `true`         |       `false`       |
|  String   |       非空字符串       |      空字符串       |
|  Number   | 非零数值（包括无穷值） |      0，`NaN`       |
|  Object   |        任意对象        |       `null`        |
| Undefined |     N/A（不存在）      |     `undefined`     |

#### 4.5 Number 类型

Number 类型使用 IEEE 754 格式表示整数和浮点值（在某些语言中也叫双精度值）。

整数可以使用十进制表示，也可以使用八进制（以 `0` 为前缀）、十六进制（以 `0x` 为前缀）。如果字面量中包含的数字超出了应有的范围，就会忽略前缀的零，后面的数字序列会被当成十进制数。

>   ES6 之后，新增了二进制表示，即 `0b` 或 `0B` 开头，十六进制使用 `0x` 或 `0X` 开头，八进制使用 `0o` 或 `0O` 开头，并且不再推荐仅使用 `0` 作为前缀，这在严格模式下报错。

```javascript
let octalNum1 = 070; // 十进制为 56
let octalNum2 = 079; // 无效的八进制，当成十进制的 79 处理
let octalNum3 = 08; // 无效的八进制，当成十进制的 8 处理

// 十六进制数字中的字母大小写均可
let hexNum1 = 0xA; // 十进制为 10
let hexNum2 = 0x1f; // 十进制为 31
```

八进制字面量在严格模式下是无效的，会导致 JavaScript 引擎抛出语法错误。

使用八进制和十六进制格式创建的数值在所有数学操作中都被视为十进制数值。

>   由于 JavaScript 保存数值的方式，实际中可能存在正零（+0）和负零（-0），两者在所有情况下都被认为是等同的。
>
>   但是，在 ES6 中，`Object.is(-0, +0)` 返回 `false`。

##### 4.5.1 浮点值

要定义浮点值，数值中必须包含小数点，而且小数点后面必须至少有一个数字。虽然小数点前面不是必须有整数，但推荐加上。

```javascript
let floatNum1 = 1.1;
let floatNum1 = .1; // 有效，但不推荐
```

因为**存储浮点值使用的内存空间是存储整数值的两倍**，所以 ECMAScript 总是想方设法把值转换为整数。在小数点后面没有数字或小数点后面跟着 0（如 1.0）的情况下，会被转换为整数：

```javascript
let floatNum1 = 1.; // 当成整数 1 处理
let floatNum2 = 10.0; // 当成整数 10 处理
```

对于非常大或非常小的数值，浮点值可以用科学记数法来表示。ECMAScript 中科学记数法的格式要求是一个数值（整数或浮点数）后跟一个`E` 或 `e`，再加上一个要乘的 10 的多少次幂。如：

```javascript
let floatNum = 3.125e7; // 31250000
```

默认情况下，ECMAScript 会将小数点后至少包含 6 个零的浮点值转换为科学记数法。

浮点数存在精度问题，很容易出错，不要将浮点数做相等比较。

```javascript
if (a + b == 0.3) { // 不要这么做
    console.log("You got 0.3.");
}
```

##### 4.5.2 值的范围

ECMAScript 可以表示的最小数值保存在 `Number.MIN_VALUE` 中，在多数浏览器中是 `5e-324`；最大数值保存在 `Number.MAX_VALUE` 中，在多数浏览器中是 `1.7976931348623157e+308`。如果某个计算得到的数值结果超出了 JavaScript 可以表示的范围，那么这个数值会被自动转换为一个特殊的 Infinity（无穷）值。任何无法表示的负数以 `-Infinity` 表示，任何无法表示的正数以 `Infinity` 表示。

要确定一个值是不是有限大，可以使用 `isFinite()` 函数，如：

```javascript
let result = Number.MAX_VALUE + Number.MAX_VALUE;
console.log(isFinite(result)); // false
```

使用 `Number.POSITIVE_INFINITY` 和 `Number.NEGATIVE_INFINITY`也可以获取正、负 Infinity。

##### 4.5.3 NaN

有一个特殊的数值叫 `NaN`，意思是“不是数值”（Not a Number），用于表示本来要返回数值的操作失败了（而不是抛出错误）。比如，在 ECMAScript 中，`0`、`+0` 或 `-0` 相除会返回 `NaN`：

```javascript
console.log(0 / 0); // NaN
console.log(-0 / +0); // NaN
```

如果分子是非 0 值，分母是有符号 0 或无符号 0，则会返回 `Infinity`或 `-Infinity`：

```javascript
console.log(5 / 0); // Infinity
console.log(5 / -0); // -Infinity
```

**任何涉及 `NaN` 的操作始终返回 `NaN`**。

`NaN` 不等于包括 `NaN` 在内的任何值：

```javascript
console.log(NaN == NaN); // false
```

ECMAScript 提供了 `isNaN()` 函数。该函数接收一个参数，然后判断这个参数是否“不是数值”。把一个值传给 `isNaN()` 后，该函数**会尝试把它转换为数值**。某些非数值的值可以直接转换成数值，如字符串 `"10"` 或布尔值。任何不能转换为数值的值都会导致这个函数返回 `true`。如：

```javascript
console.log(isNaN(NaN)); // true
console.log(isNaN(10)); // false
console.log(isNaN("10")); // false, 可以转换为数值 10
console.log(isNaN("blue")); // true
console.log(isNaN(true)); // false, 可以转换为数值1
```

首先会调用对象的 `valueOf()` 方法，然后再确定返回的值是否可以转换为数值。如果不能，再调用 `toString()` 方法，并测试其返回值。

##### 4.5.4 数值转换

有 3 个函数可以将非数值转换为数值：`Number()`、`parseInt()` 和 `parseFloat()`。 `Number()` 可用于任何数据类型，后两个函数主要用于将字符串转换为数值。

`Number()`函数基于如下规则转换：

-   布尔值，`true`转换为 1，`false`转换为 0
-   数值，直接返回
-   `null`，返回 0
-   `undefined`，返回 `NaN`
-   字符串应用以下规则：
    -   如果字符串包含的是整数格式，包括数值字符前面带加、减号的情况，则转换为一个十进制数值（忽略前面的零）
    -   如果字符串包含的是浮点数格式，则会转换为相应的浮点值（忽略前面的零）
    -   如果字符串包含有效的十六进制格式，则会转换为对应的十进制整数值
    -   如果是空字符串（不包含字符），则返回 0
    -   如果字符串包含除上述情况之外的其他字符，则返回 `NaN`
-   对象，调用 `valueOf()` 方法，并按照上述规则转换返回的值。如果转换结果是 `NaN`，则调用 `toString()` 方法，再按照转换字符串的规则转换。

```javascript
let num1 = Number("hello world!"); // NaN
let num2 = Number(""); // 0
let num3 = Number("000011"); // 11
let num4 = Number(true); // 1
```

`Number()` 使用相对复杂，通常在需要得到整数时优先使用 `parseInt()` 函数。 `parseInt()` 函数更专注于字符串是否包含数值模式。字符串最前面的空格会被忽略，从第一个非空格字符开始转换。如果第一个字符不是数值字符、进制前缀、加号或减号，`parseInt()` 立即返回 `NaN`。这意味着空字符串也会返回 `NaN`。如果第一个字符是数值字符、进制前缀、加号或减号，则继续依次检测每个字符，直到字符串末尾，或碰到非数值字符。

`parseInt()` 函数可以识别不同的进制。如果字符串以 `0x` 开头，则解释为十六进制整数；如果以 `0`开头，且紧跟着数值字符，在非严格模式下会被某些实现解释为八进制整数。

```javascript
let num1 = parseInt("1234blue"); // 1234
let num2 = parseInt(""); // NaN
let num3 = parseInt("0xA"); // 10
let num4 = parseInt(22.5); // 22
let num5 = parseInt("70"); // 70
let num6 = parseInt("0xf"); // 15
```

`parseInt()` 也接收第二个参数，用于指定底数（进制数）。如果知道要解析的值是十六进制，那么可以传入 `16` 作为第二个参数，以便正确解析：

```javascript
let num = parseInt("0xAF", 16); // 175
```

如果提供了十六进制参数，那么字符串前面的 `0x` 可以省掉：

```javascript
let num1 = parseInt("AF", 16); // 175
let num1 = parseInt("AF"); // NaN

let num3 = parseInt("10", 2) // 2
let num4 = parseInt("10", 8) // 8
let num5 = parseInt("10", 10) // 10
let num6 = parseInt("10", 16) // 16
```

因为不传底数参数相当于让 `parseInt()` 自己决定如何解析，所以为避免解析出错，建议始终传给它第二个参数。

`parseFloat()` 函数的工作方式跟 `parseInt()` 函数类似，都是从位置 0 开始检测每个字符。同样，它也是解析到字符串末尾或者解析到一个无效的浮点数值字符为止。第一次出现的小数点有效，但第二次无效，此时字符串的剩余字符都会被忽略。

`parseFloat()` 函数的另一个不同之处在于，它始终忽略字符串开头的零。这个函数能识别前面讨论的所有浮点格式，以及十进制格式（开头的零始终被忽略）。十六进制数值始终会返回 `0`。

因为 `parseFloat()` 只解析十进制值，因此不能指定底数。

如果字符串表示整数（没有小数点或小数点后面只有零），则 `parseFloat()` 返回整数。

```javascript
let num1 = parseInt("1234blue"); // 1234
let num2 = parseInt("0xA"); // 0
let num3 = parseInt("22.5"); // 22.5
let num4 = parseInt(22.5.1); // 22.5
let num5 = parseInt("0908.5"); // 908.5
let num6 = parseInt("3.125e7"); // 31250000
```

#### 4.6 String 类型

String 类型表示零或多个 16 位 Unicode 字符序列。字符串可以使用双引号、单引号或反引号标识。

JavaScript 中，单引号和双引号没有区别。但是，以某种引号作为字符串开头，必须仍然以该种引号作为字符串结尾。

##### 4.6.1 字面量

字符串数据类型包含一些字符字面量，用于表示非打印字符或有其他用途的字符，如：

| 字面量   | 含义                                      |
| -------- | ----------------------------------------- |
| `\n`     | 换行                                      |
| `\t`     | 制表                                      |
| `\b`     | 退格                                      |
| `\r`     | 回车                                      |
| `\f`     | 换页                                      |
| `\\`     | 反斜杠                                    |
| `\'`     | 单引号                                    |
| `\"`     | 双引号                                    |
| \\`      | 反引号                                    |
| `\xnn`   | 以十六进制编码 `nn` 表示的字符            |
| `\unnnn` | 以十六进制编码 `nnnn` 表示的 Unicode 字符 |

不管转义序列多长，都只表示一个字符。

字符串的长度可以通过其 `length` 属性获取：

```javascript
let text = "This is the letter sigma: \u03a3.";
console.log(text.length); // 28
```

这个属性返回字符串中 16 位字符的个数。如果字符串中包含双字节字符，那么 `length` 属性返回的值可能不是准确的字符数。

##### 4.6.2 字符串的特点

字符串是不可变的，一旦创建，它们的值就不能变了。要修改某个变量中的字符串值，必须先销毁原始的字符串，然后将包含新值的另一个字符串保存到该变量：

```javascript
let lang = "Java";
lang = lang + "Script";
```

##### 4.6.3 转换为字符串

有两种方式把一个值转换为字符串。一是使用 `toString()` 方法，其唯一的用途就是返回当前值的字符串等价物。如：

```javascript
let age = 11;
let ageAsString = age.toString(); // "11"
let found = true;
let foundAsString = found.toString(); // "true"
```

`toString()` 方法可见于数值、布尔值、对象和字符串值（字符串值也有 `toString()` 方法，只是简单地返回自身的一个副本）。`null` 和 `undefined` 没有 `toString()` 方法。

多数情况下，`toString()` 不接收任何参数。不过，在对数值调用这个方法时，`toString()` 可以接收一个底数（进制数，默认为十进制）参数。通过传入参数，可以得到数值的二进制、八进制、十六进制，或者其他任何有效基数的字符串表示，如：

```javascript
let num = 10;
console.log(num.toString()); // "10"
console.log(num.toString(2)); // "1010"
console.log(num.toString(8)); // "12"
console.log(num.toString(10)); // "10"
console.log(num.toString(16)); // "a"
```

如果不确定一个值是不是 `null` 或 `undefined`，可以使用 `String()` 转型函数，它始终会返回表示相应类型值的字符串。

`String()` 函数遵循如下规则：

-   如果值有 `toString()` 方法，则调用该方法（不传参数）并返回结果
-   如果值是 `null`，返回 `"null"`
-   如果值是 `undefined`，返回 `"undefined"`

>   用加号操作符给一个值加上一个空字符串 `""` 也可以将其转换为字符串。

##### 4.6.4 模板字面量

ECMAScript 6 新增了使用模板字面量定义字符串的能力。与使用单引号或双引号不同，模板字面量（使用反引号）保留换行字符，可以跨行定义字符串：

```javascript
let myMultiLineString = 'first line\nsecond line';
let myMultiLineTemplateLiteral = `first line
second line`;

console.log(myMultiLineString === myMultiLinetemplateLiteral); // true
```

顾名思义，模板字面量在定义 HTML 模板时特别有用。

由于模板字面量会保持反引号内部的空格，因此在使用时要格外注意。格式正确的模板字符串看起来可能会缩进不当：

```javascript
// 这个模板字面量在换行符之后有25 个空格符
let myTemplateLiteral = `first line
                          second line`;
console.log(myTemplateLiteral.length); // 47

// 这个模板字面量以一个换行符开头
let secondTemplateLiteral = `
first line
second line`;
console.log(secondTemplateLiteral[0] === '\n'); // true

// 这个模板字面量没有意料之外的字符
let thirdTemplateLiteral = `first line
second line`;
console.log(thirdTemplateLiteral);
// first line
// second line
```

##### 4.6.5 字符串插值

模板字面量最常用的一个特性是支持字符串插值，也就是可以在一个连续定义中插入一个或多个值。技术上讲，模板字面量不是字符串，而是一种特殊的 JavaScript 句法表达式，只不过求值后得到的是字符串。模板字面量在定义时立即求值并转换为字符串实例，任何插入的变量也会从它们最接近的作用域中取值。

字符串插值通过在 `${}` 中使用一个 JavaScript 表达式实现：

```javascript
let value = 5;
let exponent = 'second';
let interpolatedTemplateLiteral = 
	`${ value } to the ${ exponent } power is ${ value ＊ value }`;

console.log(interpolatedTemplateLiteral);   // 5 to the second power is 25
```

所有插入的值或表达式都会使用 `toString()` 强制转型为字符串，而且任何 JavaScript 表达式都可以用于插值。

在插值表达式中可以调用函数和方法：

```javascript
function capitalize(word) {
	return `${ word[0].toUpperCase() }${ word.slice(1) }`;
}

console.log(`${ capitalize('hello') }, ${ capitalize('world') }! `); // Hello, World!
```

模板也可以插入自己之前的值：

```javascript
let value = '';

function append() {
    value = `${value}abc`
    console.log(value);
}

append();   // abc
append();   // abcabc
append();   // abcabcabc
```

##### 4.6.6 模板字面量标签函数

模板字面量也支持定义**标签函数**，而通过标签函数可以自定义插值行为。标签函数会接收被插值记号分隔后的模板和对每个表达式求值的结果。

标签函数本身是一个常规函数，通过前缀到模板字面量来应用自定义行为。

标签函数接收到的参数依次是原始字符串数组和对每个表达式求值的结果。这个函数的返回值是对模板字面量求值得到的字符串。

```javascript
let a = 6;
let b = 9;

function simpleTag(strings, aValExpression, bValExpression, sumExpression) {
    console.log(strings);
    console.log(aValExpression);
    console.log(bValExpression);
    console.log(sumExpression);
    return 'foobar';
}

let untaggedResult = `${ a } + ${ b } = ${ a + b }`;
let taggedResult = simpleTag`${ a } + ${ b } = ${ a + b }`;
// ["", " + ", " = ", ""]
// 6
// 9
// 15
console.log(untaggedResult);    // "6 + 9 = 15"
console.log(taggedResult); // "foobar"
```

因为表达式参数的数量是可变的，所以通常应该使用剩余操作符（rest operator）将它们收集到一个数组中：

```javascript
let a = 6;
let b = 9;

functionsimpleTag (strings, ...expressions) {
    console.log(strings);
    for(const expression of expressions) {
        console.log(expression);
    }
    return 'foobar';
}

let taggedResult = simpleTag`${ a } + ${ b } = ${ a + b }`;
// ["", " + ", " = ", ""]
// 6
// 9
// 15
console.log(taggedResult); // "foobar"
```

对于有 n 个插值的模板字面量，传给标签函数的表达式参数的个数始终是 n，而传给标签函数的第一个参数所包含的字符串个数则始终是 n+1。因此，如果想把这些字符串和对表达式求值的结果拼接起来作为默认返回的字符串，可以这样做：

```javascript
let a = 6;
let b = 9;

function zipTag(strings, ...expressions) {
    return strings[0] +
        expressions.map((e, i) => `${e}${strings[i + 1]}`)
        .join('');
}

let untaggedResult =     `${ a } + ${ b } = ${ a + b }`;
let taggedResult = zipTag`${ a } + ${ b } = ${ a + b }`;
console.log(untaggedResult); 	// "6 + 9 = 15"
console.log(taggedResult);   	// "6 + 9 = 15"
```

##### 4.6.7 原始字符串

使用模板字面量也可以直接获取原始的模板字面量内容，而不是被转换后的字符表示。为此，可以使用默认的 `String.raw` 标签函数：

```javascript
// Unicode 示例
// \u00A9 是版权符号
console.log(`\u00A9`); // ©
console.log(String.raw`\u00A9`); // \u00A9

// 换行符示例
console.log(`first line\nsecond line`);
// first line
// second line
console.log(String.raw`first line\nsecond line`); // "first line\nsecond line"

// 对实际的换行符来说无效, 它不会被转换成转义序列的形式
console.log(`first line
second line`);
// first line
// second line
console.log(String.raw`first line
second line`);
// first line
// second line
```

也可以通过标签函数的第一个参数，即字符串数组的 `.raw` 属性取得每个字符串的原始内容：

```javascript
function printRaw(strings) {
    console.log('Actual characters:');
    for (const string of strings) {
        console.log(string);
    }
    console.log('Escaped characters; ');
    for (const rawString of strings.raw) {
        console.log(rawString);
    }
}
printRaw`\u00A9${ 'and' }\n`;
// Actual characters:
// ©
//（换行符）
// Escaped characters:
// \u00A9
// \n
```

#### 4.7 Symbol 类型

Symbol 是 ECMAScript 6 新增的数据类型。符号是原始值，且符号实例是唯一、不可变的。符号的用途是确保对象属性使用唯一标识符，不会发生属性冲突的危险。

尽管听起来跟私有属性有点类似，但符号并不是为了提供私有属性的行为才增加的。相反，符号就是用来创建唯一记号，进而用作非字符串形式的对象属性。

##### 4.7.1 符号的基本用法

符号需要使用 `Symbol()` 函数初始化。因为符号本身是原始类型，所以 `typeof` 操作符对符号返回 `"symbol"`。

```javascript
let sym = Symbol();
console.log(typeof sym); // "symbol"
```

调用 `Symbol()` 函数时，也可以传入一个字符串参数作为对符号的描述，将来可以通过这个字符串来调试代码。但是，这个字符串参数与符号定义或标识完全无关：

```javascript
let genericSymbol = Symbol();
let otherGenericSymbol = Symbol();
let fooSymbol = Symbol('foo');
let otherFooSymbol = Symbol('foo');
console.log(genericSymbol == otherFooSymbol); // false
console.log(fooSymbol == otherFooSymbol); // false
```

符号没有字面量语法，这也是它们发挥作用的关键。按照规范，只要创建 `Symbol()` 实例并将其用作对象的新属性，就可以保证它不会覆盖已有的对象属性，无论是符号属性还是字符串属性。

```javascript
let genericSymbol = Symbol();
console.log(genericSymbol);   // Symbol()
let fooSymbol = Symbol('foo');
console.log(fooSymbol); // Symbol('foo')
```

`Symbol()` 函数不能与 `new` 关键字一起作为构造函数使用。这样做是为了避免创建符号包装对象，像使用 Boolean、String 或 Number 那样，它们都支持构造函数且可用于初始化包含原始值的包装对象：

```javascript
let myBoolean = new Boolean();
console.log(typeof myBoolean); // "object"
let myString = new String();
console.log(typeof myString); // "object"
let myNumber = new Number();
console.log(typeof myNumber); // "object"
let mySymbol = new Symbol(); // TypeError: Symbol is not a constructor
```

如果想使用符号包装对象，可以借用 `Object()` 函数：

```javascript
let mySymbol = Symbol();
let myWrappedSymbol = Object(mySymbol);
console.log(typeof myWrappedSymbol); // "object"
```

##### 4.7.2 使用全局符号注册表

如果运行时的不同部分需要共享和重用符号实例，那么可以用一个字符串作为键，在全局符号注册表中创建并重用符号。为此，需要使用 `Symbol.for()` 方法：

```javascript
let fooGlobalSymbol = Symbol.for('foo');
console.log(typeof fooGlobalSymbol); // symbol
```

`Symbol.for()` 对每个字符串键都执行**幂等**操作。第一次使用某个字符串调用时，它会检查全局运行时注册表，发现不存在对应的符号，于是生成一个新符号实例并添加到注册表中。后续使用相同字符串的调用同样会检查注册表，发现存在与该字符串对应的符号，然后就会返回该符号实例。

```javascript
let fooGlobalSymbol = Symbol.for('foo'); // 创建新符号
let otherFooGlobalSymbol = Symbol.for('foo'); // 重用已有符号
console.log(fooGlobalSymbol === otherFooGlobalSymbol); // true
```

即使采用相同的符号描述，在全局注册表中定义的符号跟使用 `Symbol()` 定义的符号也并不等同：

```javascript
let localSymbol = Symbol('foo');
let globalSymbol = Symbol.for('foo');
console.log(localSymbol === globalSymbol); // false
```

全局注册表中的符号必须使用字符串键来创建，因此作为参数传给 `Symbol.for()` 的任何值都会被转换为字符串。此外，注册表中使用的键同时也会被用作符号描述。

```javascript
let emptyGlobalSymbol = Symbol.for();
console.log(emptyGlobalSymbol); // Symbol(undefined)
```

还可以使用 `Symbol.keyFor()` 来查询全局注册表，这个方法接收符号，返回该全局符号对应的字符串键。如果查询的不是全局符号，则返回 `undefined`。

```javascript
// 创建全局符号
let s = Symbol.for('foo');
console.log(Symbol.keyFor(s)); // foo
// 创建普通符号
let s2 = Symbol('bar');
console.log(Symbol.keyFor(s2)); // undefined
```

如果传给 `Symbol.keyFor()` 的不是符号，则该方法抛出 `TypeError`：

```javascript
Symbol.keyFor(123); // TypeError: 123 is not a symbol
```

##### 4.7.3 使用符号作为属性

凡是可以使用字符串或数值作为属性的地方，都可以使用符号。这包括对象字面量属性和 `Object.defineProperty()` / `Object.defineProperties()` 定义的属性。对象字面量只能在计算属性语法中使用符号作为属性。

```javascript
let s1 = Symbol('foo'),
    s2 = Symbol('bar'),
    s3 = Symbol('baz'),
    s4 = Symbol('qux');

let o = {
    [s1]: 'foo val'
}; // 这样也可以：o[s1] = 'foo val';
console.log(o); // {Symbol(foo): foo val}

Object.defineProperty(o, s2, {value: 'bar val'});
console.log(o); // {Symbol(foo): foo val, Symbol(bar): bar val}

Object.defineProperties(o, {
    [s3]: {value: 'baz val'},
    [s4]: {value: 'qux val'}
});
console.log(o);
// {Symbol(foo): foo val, Symbol(bar): bar val, Symbol(baz): baz val, Symbol(qux): qux val
```

类似于 `Object.getOwnPropertyNames()` 返回对象实例的常规属性数组， `Object.getOwnProperty-Symbols()` 返回对象实例的符号属性数组。这两个方法的返回值彼此互斥。`Object.getOwnProperty-Descriptors()` 会返回同时包含常规和符号属性描述符的对象。`Reflect.ownKeys()` 会返回两种类型的键：

```javascript
let s1 = Symbol('foo'),
    s2 = Symbol('bar');

let o = {
    [s1]: 'foo val',
    [s2]: 'bar val',
    baz: 'baz val',
    qux: 'qux val'
};

console.log(Object.getOwnPropertySymbols(o)); // [Symbol(foo), Symbol(bar)]

console.log(Object.getOwnPropertyNames(o)); // ["baz", "qux"]

console.log(Object.getOwnPropertyDescriptors(o));
// {baz: {...}, qux: {...}, Symbol(foo): {...}, Symbol(bar): {...}}

console.log(Reflect.ownKeys(o));
// ["baz", "qux", Symbol(foo), Symbol(bar)]
```

因为符号属性是对内存中符号的一个引用，所以直接创建并用作属性的符号不会丢失。但是，如果没有显式地保存对这些属性的引用，那么必须遍历对象的所有符号属性才能找到相应的属性键：

```javascript
let o = {
    [Symbol('foo')]: 'fooval',
    [Symbol('bar')]: 'barval'
};
console.log(o); // {Symbol(foo): "foo val", Symbol(bar): "bar val"}

let barSymbol = Object.getOwnPropertySymbols(o).find((symbol) => symbol.toString().match(/bar/));

console.log(barSymbol); // Symbol(bar)
```

##### 4.7.4 常用内置符号

ECMAScript 6 也引入了一批常用内置符号，用于暴露语言内部行为，开发者可以直接访问、重写或模拟这些行为。这些内置符号都以 Symbol 工厂函数字符串属性的形式存在。

这些内置符号最重要的用途之一是重新定义它们，从而改变原生结构的行为。比如，`for-of` 循环会在相关对象上使用 `Symbol.iterator` 属性，那么就可以通过在自定义对象上重新定义 `Symbol.iterator` 的值，来改变 `for-of` 在迭代该对象时的行为。

这些内置符号是全局函数 Symbol 的普通字符串属性，指向一个符号的实例。所有内置符号属性都是不可写、不可枚举、不可配置的。

>   在提到 ECMAScript 规范时，经常会引用符号在规范中的名称，前缀为 `@@`，如 `@@iterator` 指的就是 `Symbol.iterator`。

##### 4.7.5 Symbol.asyncIterator

根据 ECMAScript 规范，这个符号作为一个属性表示“一个方法，该方法返回对象默认的 `AsyncIterator`，由 `for-await-of` 语句使用”。换句话说，这个符号表示实现异步迭代器 API 的函数。`for-await-of` 循环会利用这个函数执行异步迭代操作。循环时，会调用以 `Symbol.asyncIterator` 为键的函数，并期望这个函数会返回一个实现迭代器 API 的对象。很多时候，返回的对象是实现该 API 的 `AsyncGenerator`：

```javascript
class Foo {
    async *[Symbol.asyncIterator]() {}
}

let f = new Foo();
console.log(f[Symbol.asyncIterator]()); // AsyncGenerator {<suspended>}
```

技术上，这个由 `Symbol.asyncIterator` 函数生成的对象应该通过其 `next()` 方法陆续返回 Promise 实例。可以通过显式地调用 `next()` 方法返回，也可以隐式地通过异步生成器函数返回：

```javascript
class Emitter {
    constructor(max) {
        this.max = max;
        this.asyncIdx = 0;
    }
    async *[Symbol.asyncIterator](){
        while(this.asyncIdx < this.max) {
            yield new Promise((resolve) => resolve(this.asyncIdx++));
        }
    }
}

async function asyncCount() {
    let emitter = new Emitter(5);
    for await(const x of emitter) {
        console.log(x);
    }
}

asyncCount();
// 0
// 1
// 2
// 3
// 4
```

>   `Symbol.asyncIterator` 是 ES2018 规范定义的，因此只有版本非常新的浏览器支持它。

##### 4.7.6 Symbol.hasInstance

根据 ECMAScript 规范，这个符号作为一个属性表示“一个方法，该方法决定一个构造器对象是否认可一个对象是它的实例，由 `instanceof` 操作符使用”。`instanceof` 操作符可以用来确定一个对象实例的原型链上是否有原型。`instanceof` 的典型使用场景如下：

```javascript
function Foo() {}
let f = new Foo();
console.log(f instanceof Foo); // true
class Bar {}
let b = new Bar();
console.log(b instanceof Bar); // true
```

在 ES6 中，`instanceof` 操作符会使用 `Symbol.hasInstance` 函数来确定关系。以 `Symbol.hasInstance` 为键的函数会执行同样的操作，只是操作数对调了一下：

```javascript
function Foo() {}
let f = new Foo();
console.log(Foo[Symbol.hasInstance](f)); // true
class Bar {}
let b = new Bar();
console.log(Bar[Symbol.hasInstance](b)); // true
```

这个属性定义在 Function 的原型上，因此默认在所有函数和类上都可以调用。由于 `instanceof` 操作符会在原型链上寻找这个属性定义，就跟在原型链上寻找其他属性一样，因此可以在继承的类上通过静态方法重新定义这个函数：

```javascript
class Bar {}
class Baz extends Bar {
    static[Symbol.hasInstance](){
        return false;
    }
}
let b = new Baz();
console.log(Bar[Symbol.hasInstance](b)); // true
console.log(b instanceof Bar); // true
console.log(Baz[Symbol.hasInstance](b));  //false
console.log(b instanceof Baz); // false
```

##### 4.7.7 Symbol.isConcatSpreadable

根据 ECMAScript 规范，这个属性表示“一个布尔值，如果是 `true`，则意味着对象应该用 `Array.prototype.concat()` 打平其数组元素”。

ES6 中的 `Array.prototype.concat()` 方法会根据接收到的对象类型选择如何将一个类数组对象拼接成数组实例。覆盖 `Symbol.isConcatSpreadable` 的值可以修改这个行为。

数组对象默认情况下会被打平到已有的数组，`false` 或假值会导致整个对象被追加到数组末尾。类数组对象默认情况下会被追加到数组末尾，`true` 或真值会导致这个类数组对象被打平到数组实例。其他不是类数组对象的对象在 `Symbol.isConcatSpreadable` 被设置为 `true` 的情况下将被忽略。

```javascript
let initial = ['foo'];
let array = ['bar'];

console.log(array[Symbol.isConcatSpreadable]); // undefined
console.log(initial.concat(array)); // ['foo', 'bar']

array[Symbol.isConcatSpreadable] = false;
console.log(initial.concat(array)); // ['foo', Array(1)]

let arrayLikeObject = { length: 1, 0: 'baz' };

console.log(arrayLikeObject[Symbol.isConcatSpreadable]); // undefined
console.log(initial.concat(arrayLikeObject)); // ['foo', {...}]

arrayLikeObject[Symbol.isConcatSpreadable] = true;
console.log(initial.concat(arrayLikeObject)); // ['foo', 'baz']

let otherObject = new Set().add('qux');

console.log(otherObject[Symbol.isConcatSpreadable]); // undefined
console.log(initial.concat(otherObject)); // ['foo', Set(1)]
otherObject[Symbol.isConcatSpreadable] = true;
console.log(initial.concat(otherObject)); // ['foo']
```

##### 4.7.8 `Symbol.iterator`

根据 ECMAScript 规范，这个属性表示“一个方法，该方法返回对象默认的迭代器，由 `for-of` 语句使用”。换句话说，这个符号表示实现迭代器 API 的函数。`for-of` 循环这样的语言结构会利用这个函数执行迭代操作。循环时，它们会调用以 `Symbol.iterator` 为键的函数，并默认这个函数会返回一个实现迭代器 API 的对象。很多时候，返回的对象是实现该 API 的 Generator：

```javascript
class Foo {
    ＊[Symbol.iterator]() {}
}
let f = new Foo();
console.log(f[Symbol.iterator]()); // Generator {<suspended>}
```

技术上，这个由 `Symbol.iterator` 函数生成的对象应该通过其 `next()` 方法陆续返回值。可以通过显式地调用 `next()` 方法返回，也可以隐式地通过生成器函数返回：

```javascript
class Emitter {
    constructor(max) {
        this.max = max;
        this.idx = 0;
    }
    *[Symbol.iterator](){
        while(this.idx < this.max) {
            yield this.idx++;
        }
    }
}

function count() {
    let emitter = new Emitter(5);
    for (const x of emitter) {
        console.log(x);
    }
}

count();
// 0
// 1
// 2
// 3
// 4
```

##### 4.7.9 `Symbol.match`

根据 ECMAScript 规范，这个属性表示“一个正则表达式方法，该方法用正则表达式去匹配字符串，由 `String.prototype.match()` 方法使用”。`String.prototype.match()` 方法会使用以 `Symbol.match` 为键的函数来对正则表达式求值。正则表达式的原型上默认有这个函数的定义，因此所有正则表达式实例默认是这个 String 方法的有效参数：

```javascript
console.log(RegExp.prototype[Symbol.match]); // f [Symbol.match]() { [native code] }
console.log('foobar'.match(/bar/)); // ["bar", index: 3, input: "foobar", groups: undefined]
```

给这个方法传入非正则表达式值会导致该值被转换为 RegExp 对象。如果想改变这种行为，让方法直接使用参数，则可以重新定义 `Symbol.match` 函数以取代默认对正则表达式求值的行为，从而让 `match()` 方法使用非正则表达式实例。`Symbol.match` 函数接收一个参数，就是调用 `match()` 方法的字符串实例。返回的值没有限制：

```javascript
class FooMatcher {
    static[Symbol.match](target){
        return target.includes('foo');
    }
}
console.log('foobar'.match(FooMatcher)); // true
console.log('barbaz'.match(FooMatcher)); // false

class StringMatcher {
    constructor(str) {
        this.str = str;
    }
    [Symbol.match](target){
        returntarget.includes(this.str);
    }
}
console.log('foobar'.match(new StringMatcher('foo'))); // true
console.log('barbaz'.match(new StringMatcher('foo'))); // false
```

##### 4.7.10 `Symbol.replace`

根据 ECMAScript 规范，这个属性表示“一个正则表达式方法，该方法替换一个字符串中匹配的子串，由 `String.prototype.replace()` 方法使用”。`String.prototype.replace()` 方法会使用以 `Symbol.replace` 为键的函数来对正则表达式求值。正则表达式的原型上默认有这个函数的定义，因此所有正则表达式实例默认是这个 String 方法的有效参数：

```javascript
console.log(RegExp.prototype[Symbol.replace]); // f [Symbol.replace]() { [native code] }
console.log('foobarbaz'.replace(/bar/, 'qux')); // 'fooquxbaz'
```

给这个方法传入非正则表达式值会导致该值被转换为 RegExp 对象。如果想改变这种行为，让方法直接使用参数，可以重新定义 `Symbol.replace` 函数以取代默认对正则表达式求值的行为，从而让 `replace()` 方法使用非正则表达式实例。`Symbol.replace` 函数接收两个参数，即调用 `replace()` 方法的字符串实例和替换字符串。返回的值没有限制：

```javascript
class FooReplacer {
    static[Symbol.replace](target, replacement){
        returntarget.split('foo').join(replacement);
    }
}
console.log('barfoobaz'.replace(FooReplacer, 'qux')); // "barquxbaz"

class StringReplacer {
    constructor(str) {
        this.str = str;
    }
    [Symbol.replace](target, replacement){
        returntarget.split(this.str).join(replacement);
    }
}
console.log('barfoobaz'.replace(new StringReplacer('foo'), 'qux')); // "barquxbaz"
```

##### 4.7.11 `Symbol.search`

根据 ECMAScript 规范，这个属性表示“一个正则表达式方法，该方法返回字符串中匹配正则表达式的索引，由 `String.prototype.search()` 方法使用”。

`String.prototype.search()` 方法会使用以 `Symbol.search` 为键的函数来对正则表达式求值。正则表达式的原型上默认有这个函数的定义，因此所有正则表达式实例默认是这个 String 方法的有效参数：

```javascript
console.log(RegExp.prototype[Symbol.search]); // f [Symbol.search]() { [native code] }
console.log('foobar'.search(/bar/)); // 3
```

给这个方法传入非正则表达式值会导致该值被转换为 RegExp 对象。如果想改变这种行为，让方法直接使用参数，可以重新定义 `Symbol.search` 函数以取代默认对正则表达式求值的行为，从而让 `search()` 方法使用非正则表达式实例。`Symbol.search` 函数接收一个参数，就是调用 `match()` 方法的字符串实例。返回的值没有限制：

```javascript
class FooSearcher {
    static[Symbol.search](target){
        returntarget.indexOf('foo');
    }
}
console.log('foobar'.search(FooSearcher)); // 0
console.log('barfoo'.search(FooSearcher)); // 3
console.log('barbaz'.search(FooSearcher)); // -1

class StringSearcher {
    constructor(str) {
        this.str = str;
    }
    [Symbol.search](target){
        returntarget.indexOf(this.str);
    }
}
console.log('foobar'.search(new StringSearcher('foo'))); // 0
console.log('barfoo'.search(new StringSearcher('foo'))); // 3
console.log('barbaz'.search(new StringSearcher('qux'))); // -1
```

##### 4.7.12 `Symbol.species`

根据 ECMAScript 规范，这个属性表示“一个函数值，该函数作为创建派生对象的构造函数”。这个属性在内置类型中最常用，用于对内置类型实例方法的返回值暴露实例化派生对象的方法。用 `Symbol.species` 定义静态的获取器（getter）方法，可以覆盖新创建实例的原型定义：

```javascript
class Bar extends Array {}
class Baz extends Array {
    staticget[Symbol.species](){
        returnArray;
    }
}
let bar = new Bar();
console.log(bar instanceof Array); // true
console.log(bar instanceof Bar);   // true
bar = bar.concat('bar');
console.log(bar instanceof Array); // true
console.log(bar instanceof Bar);   // true
let baz = new Baz();
console.log(baz instanceof Array); // true
console.log(baz instanceof Baz);   // true
baz = baz.concat('baz');
console.log(baz instanceof Array); // true
console.log(baz instanceof Baz);   // false 
```

##### 4.7.13 `Symbol.split`

根据 ECMAScript 规范，这个属性表示“一个正则表达式方法，该方法在匹配正则表达式的索引位置拆分字符串。由 `String.prototype.split()` 方法使用”。`String.prototype.split()` 方法会使用以 `Symbol.split` 为键的函数来对正则表达式求值。正则表达式的原型上默认有这个函数的定义，因此所有正则表达式实例默认是这个 String 方法的有效参数：

```javascript
console.log(RegExp.prototype[Symbol.split]); // f [Symbol.split]() { [native code] }
console.log('foobarbaz'.split(/bar/)); // ['foo', 'baz']
```

给这个方法传入非正则表达式值会导致该值被转换为 RegExp 对象。如果想改变这种行为，让方法直接使用参数，可以重新定义 `Symbol.split` 函数以取代默认对正则表达式求值的行为，从而让 `split()` 方法使用非正则表达式实例。`Symbol.split` 函数接收一个参数，就是调用 `match()` 方法的字符串实例。返回的值没有限制：

```javascript
class FooSplitter {
    static[Symbol.split](target){
        returntarget.split('foo');
    }
}
console.log('barfoobaz'.split(FooSplitter)); // ["bar", "baz"]

class StringSplitter {
    constructor(str) {
        this.str = str;
    }
    [Symbol.split](target){
        returntarget.split(this.str);
    }
}
console.log('barfoobaz'.split(new StringSplitter('foo'))); // ["bar", "baz"]
```

##### 4.7.14 `Symbol.toPrimitive`

根据 ECMAScript 规范，这个属性表示“一个方法，该方法将对象转换为相应的原始值。由 `ToPrimitive` 抽象操作使用”。很多内置操作都会尝试强制将对象转换为原始值，包括字符串、数值和未指定的原始类型。对于一个自定义对象实例，通过在这个实例的 `Symbol.toPrimitive` 属性上定义一个函数可以改变默认行为。

根据提供给这个函数的参数（string、number或default），可以控制返回的原始值：

```javascript
class Foo {}
let foo = new Foo();
console.log(3 + foo); // "3[object Object]"
console.log(3- foo); // NaN
console.log(String(foo)); // "[object Object]"
class Bar {
    constructor() {
        this[Symbol.toPrimitive]=function(hint){
            switch(hint){
                case'number':
                    return3;
                case'string':
                    return'stringbar';
                case'default':
                default:
                    return'defaultbar';
            }
        }
    }
}
let bar = new Bar();
console.log(3 + bar); // "3default bar"
console.log(3- bar); // 0
console.log(String(bar)); // "string bar"
```

##### 4.7.15 `Symbol.toStringTag`

根据 ECMAScript 规范，这个符号作为一个属性表示“一个字符串，该字符串用于创建对象的默认字符串描述，由内置方法 `Object.prototype.toString()` 使用”。

通过 `toString()` 方法获取对象标识时，会检索由 `Symbol.toStringTag` 指定的实例标识符，默认为 `"Object"`。内置类型已经指定了这个值，但自定义类实例还需要明确定义：

```javascript
let s = new Set();
console.log(s); // Set(0) {}
console.log(s.toString()); // [object Set]
console.log(s[Symbol.toStringTag]); // Set

class Foo {}
let foo = new Foo();
console.log(foo); // Foo {}
console.log(foo.toString()); // [object Object]
console.log(foo[Symbol.toStringTag]); // undefined

class Bar {
    constructor() {
        this[Symbol.toStringTag] = 'Bar';
    }
}
let bar = new Bar();
console.log(bar); // Bar {}
console.log(bar.toString()); // [object Bar]
console.log(bar[Symbol.toStringTag]); // Bar
```

##### 4.7.16 `Symbol.unscopables`

根据 ECMAScript 规范，这个属性表示“一个对象，该对象所有的以及继承的属性，都会从关联对象的 `with` 环境绑定中排除”。设置这个符号并让其映射对应属性的键值为 `true`，就可以阻止该属性出现在 `with` 环境绑定中，如下例所示：

```javascript
let o = { foo: 'bar' };
with (o) {
    console.log(foo); // bar
}
o[Symbol.unscopables] = {
    foo: true
};
with (o) {
    console.log(foo); // ReferenceError
}
```

>   不推荐使用 `with`，因此也不推荐使用 `Symbol.unscopables`。

 #### 4.8 Object类型

ECMAScript 中的对象其实就是一组数据和功能的集合。对象通过 `new` 操作符后跟对象类型的名称来创建。开发者可以通过创建 Object 类型的实例来创建自己的对象，然后再给对象添加属性和方法：

```javascript
let o = new Object();
```

如果没有参数，那么完全可以省略括号（不推荐）：

```javascript
let o = new Object; // 合法，但不推荐
```

ECMAScript 中的 Object 是派生其他对象的基类，Object 类型的所有属性和方法在派生的对象上同样存在。

每个 Object 实例都有如下属性和方法：

-   `constructor`：用于创建当前对象的函数。在前面的例子中，这个属性的值就是Object()函数
-   `hasOwnProperty(propertyName)`：用于判断当前对象实例（不是原型）上是否存在给定的属性。要检查的属性名必须是字符串（如 `o.hasOwnProperty("name")`）或符号
-   `isPrototypeOf(object)`：用于判断当前对象是否为另一个对象的原型
-   `propertyIsEnumerable(propertyName)`：用于判断给定的属性是否可以使用 `for-in` 语句枚举。与 `hasOwnProperty()` 一样，属性名必须是字符串
-   `toLocaleString()`：返回对象的字符串表示，该字符串反映对象所在的本地化执行环境
-   `toString()`：返回对象的字符串表示
-   `valueOf()`：返回对象对应的字符串、数值或布尔值表示。通常与 `toString()` 的返回值相同

因为在 ECMAScript 中 Object 是所有对象的基类，所以任何对象都有这些属性和方法。





